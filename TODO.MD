Essa Ã© uma decisÃ£o excelente. Ao utilizar o **Gemini-Flash** e a **API de Embeddings da Google**, vocÃª mantÃ©m a qualidade e a velocidade necessÃ¡rias para um Agente em produÃ§Ã£o, enquanto otimiza o uso de recursos gratuitos ou de baixo custo, conforme solicitado.

A arquitetura lÃ³gica que definimos (**Plan-and-Execute, Text-to-SQL, Cache TTL**) Ã© robusta o suficiente para a transiÃ§Ã£o. As informaÃ§Ãµes adicionais necessÃ¡rias para a construÃ§Ã£o (e que confirmam o seu pedido) sÃ£o sobre a **conexÃ£o e as bibliotecas especÃ­ficas** a serem usadas, mantendo o restante da infraestrutura (SQLite, FAISS/ChromaDB) local.

---

## ğŸ› ï¸ Stack TecnolÃ³gico Final - DecisÃµes Confirmadas

As principais decisÃµes tÃ©cnicas para a construÃ§Ã£o, focando na integraÃ§Ã£o direta com as APIs do Google e ferramentas locais:

### 1. LLM e OrquestraÃ§Ã£o (Agente Planejador e Executores)

| Componente | DecisÃ£o TÃ©cnica | ImplementaÃ§Ã£o |
| :--- | :--- | :--- |
| **Modelo Principal** | **Gemini 1.5 Flash** | Via LangChain: `ChatGoogleGenerativeAI(model="gemini-1.5-flash", temperature=0)` |
| **ConexÃ£o** | **Google AI API Key** (nÃ£o Vertex AI) | Configurar via variÃ¡vel de ambiente `GOOGLE_API_KEY` |
| **System Prompts** | InjeÃ§Ã£o direta no prompt | Schema SQL injetado no prompt do SQL Runner (sem RAG adicional) |
| **Function Calling** | Nativo do Gemini | LangChain `@tool` decorator para definir as 3 tools |
| **Framework** | **LangChain** | Usar `AgentExecutor` com Gemini como backend |

### 2. RAG e Embeddings (Cache Web - TTL)

| Componente | DecisÃ£o TÃ©cnica | ImplementaÃ§Ã£o |
| :--- | :--- | :--- |
| **Modelo de Embeddings** | **Google `models/embedding-001`** | Via LangChain: `GoogleGenerativeAIEmbeddings(model="models/embedding-001")` |
| **Base Vetorial** | **FAISS (local)** | `FAISS.from_documents()` + `FAISS.save_local()` / `FAISS.load_local()` |
| **Metadados dos Chunks** | JSON estruturado | `{"brewery_name": "...", "url": "...", "summary": "...", "creation_date": "YYYY-MM-DD", "brewery_type": "..."}` |
| **TTL (Time-to-Live)** | 30 dias | CÃ¡lculo: `(datetime.now() - datetime.fromisoformat(creation_date)).days > 30` |

**OBS:** NÃ£o haverÃ¡ RAG Index 1 para Text-to-SQL. O schema serÃ¡ injetado diretamente no System Prompt do SQL Runner.

### 3. Banco de Dados SQL

| Componente | DecisÃ£o TÃ©cnica | ImplementaÃ§Ã£o |
| :--- | :--- | :--- |
| **Banco de Dados** | **SQLite** (`customers.db`) | Arquivo local jÃ¡ existente |
| **ConexÃ£o** | LangChain SQLDatabase | `SQLDatabase.from_uri("sqlite:///customers.db")` |
| **Tabela** | `client_profiles` | Schema completo injetado no prompt do SQL Runner |

### 4. APIs Externas

| Componente | DecisÃ£o TÃ©cnica | ImplementaÃ§Ã£o |
| :--- | :--- | :--- |
| **Busca de Cervejarias** | **OpenBreweryDB API** | RequisiÃ§Ã£o direta via `requests`: `https://api.openbrewerydb.org/v1/breweries` |
| **Web Search (Fallback)** | **Google Search API** | Via LangChain Tool ou SDK do Google |
| **Web Scraping** | **BeautifulSoup4** | ExtraÃ§Ã£o de conteÃºdo HTML limpo antes de resumir com Gemini |

### 5. Logging e Observabilidade

| Componente | DecisÃ£o TÃ©cnica | ImplementaÃ§Ã£o |
| :--- | :--- | :--- |
| **Sistema de Log** | Python `logging` + JSON | Logs estruturados salvos em `logs/execution_{timestamp}.json` |
| **MÃ©tricas** | Rastreamento manual | Tempo de execuÃ§Ã£o, tool calls, cache hit rate, tokens estimados |
| **Chain-of-Thought** | Trace completo | SequÃªncia de tool calls + inputs/outputs + decisÃµes condicionais |

---

## ğŸ¯ Roadmap de ImplementaÃ§Ã£o

Com a infraestrutura lÃ³gica e as ferramentas definidas, a construÃ§Ã£o segue esta sequÃªncia:

### Fase 1: Setup Inicial
1. **DependÃªncias:**
   ```bash
   pip install langchain langchain-google-genai faiss-cpu beautifulsoup4 requests sqlalchemy
   ```

2. **VariÃ¡veis de Ambiente:**
   ```bash
   export GOOGLE_API_KEY="sua-api-key-aqui"
   ```

3. **Estrutura de DiretÃ³rios:**
   ```
   BESS-TecnicalCase/
   â”œâ”€â”€ customers.db              # Banco SQLite (jÃ¡ existe)
   â”œâ”€â”€ tools/                    # Ferramentas (Tools)
   â”‚   â”œâ”€â”€ __init__.py
   â”‚   â”œâ”€â”€ sql_runner.py        # Tool 1
   â”‚   â”œâ”€â”€ brewery_finder.py    # Tool 2
   â”‚   â””â”€â”€ web_explorer.py      # Tool 3
   â”œâ”€â”€ agents/                   # Agentes
   â”‚   â”œâ”€â”€ __init__.py
   â”‚   â””â”€â”€ planner.py           # Agente Orquestrador
   â”œâ”€â”€ utils/                    # UtilitÃ¡rios
   â”‚   â”œâ”€â”€ __init__.py
   â”‚   â”œâ”€â”€ logger.py            # Sistema de logging
   â”‚   â”œâ”€â”€ rag_manager.py       # Gerenciamento do FAISS
   â”‚   â””â”€â”€ chat_session.py      # Gerenciamento de sessÃ£o de chat
   â”œâ”€â”€ api/                      # API REST (FastAPI)
   â”‚   â”œâ”€â”€ __init__.py
   â”‚   â”œâ”€â”€ main.py              # App FastAPI principal
   â”‚   â”œâ”€â”€ models/
   â”‚   â”‚   â”œâ”€â”€ __init__.py
   â”‚   â”‚   â”œâ”€â”€ request.py       # Pydantic request models
   â”‚   â”‚   â””â”€â”€ response.py      # Pydantic response models
   â”‚   â”œâ”€â”€ routes/
   â”‚   â”‚   â”œâ”€â”€ __init__.py
   â”‚   â”‚   â”œâ”€â”€ chat.py          # Endpoints de chat
   â”‚   â”‚   â”œâ”€â”€ health.py        # Health check
   â”‚   â”‚   â””â”€â”€ metrics.py       # MÃ©tricas
   â”‚   â”œâ”€â”€ middleware/
   â”‚   â”‚   â”œâ”€â”€ __init__.py
   â”‚   â”‚   â”œâ”€â”€ auth.py          # API Key validation
   â”‚   â”‚   â””â”€â”€ rate_limit.py    # Rate limiting
   â”‚   â””â”€â”€ session_manager.py   # Gerenciamento de sessÃµes
   â”œâ”€â”€ prompts/                  # System Prompts (jÃ¡ existe)
   â”œâ”€â”€ data/                     # Dados persistentes
   â”‚   â””â”€â”€ faiss_index/         # Ãndice FAISS salvo
   â”œâ”€â”€ logs/                     # Logs de execuÃ§Ã£o
   â”œâ”€â”€ tests/                    # Testes unitÃ¡rios e E2E
   â”‚   â”œâ”€â”€ __init__.py
   â”‚   â”œâ”€â”€ test_tools.py
   â”‚   â”œâ”€â”€ test_agent.py
   â”‚   â””â”€â”€ test_api.py
   â”œâ”€â”€ main.py                   # CLI Conversacional
   â”œâ”€â”€ requirements.txt          # DependÃªncias
   â””â”€â”€ .env.example              # Exemplo de variÃ¡veis de ambiente
   ```

### Fase 2: ConstruÃ§Ã£o das Tools
1. **Tool 1 (SQL Runner):**
   - Conectar ao `customers.db` via `SQLDatabase`
   - Implementar geraÃ§Ã£o de SQL via Gemini com schema injetado
   - Adicionar lÃ³gica de fallback (client_id â†’ postal_code â†’ client_name)
   - Retornar JSON estruturado com resultado

2. **Tool 2 (Brewery Finder):**
   - Chamar OpenBreweryDB API com filtros
   - Implementar filtro de histÃ³rico (case-insensitive)
   - Tratamento robusto de erros (API_ERROR, NO_BREWERIES, NO_NEW_BREWERIES)
   - Retornar JSON estruturado

3. **Tool 3 (Web Explorer):**
   - Inicializar/Carregar Ã­ndice FAISS com Google Embeddings
   - Implementar lÃ³gica de Cache TTL (30 dias)
   - Fallback para Google Search + BeautifulSoup + Gemini
   - Persistir Ã­ndice FAISS apÃ³s atualizaÃ§Ã£o
   - Retornar JSON com source (cache/web_search)

### Fase 3: Agente Orquestrador
1. **Planner Agent:**
   - Inicializar Gemini 1.5 Flash via LangChain
   - Registrar as 3 Tools com `@tool` decorator
   - Implementar System Prompt completo (5 passos)
   - Adicionar lÃ³gica condicional (Passo 3/4) com timeout 30s
   - Gerenciar chat loop com estado

### Fase 4: Logging e Observabilidade
1. **Sistema de Logging:**
   - Configurar `logging` com formato JSON
   - Logar cada tool call (timestamp, args, result, execution_time)
   - Gerar Chain-of-Thought trace ao final
   - Calcular mÃ©tricas (tempo total, cache hit rate, tokens)

### Fase 5: Interface CLI (main.py)
1. **Script Conversacional Interativo:**
   - Implementar classe `ChatSession` para gerenciar estado
   - Usar biblioteca `rich` para interface colorida e formatada
   - Implementar loop conversacional com contexto persistente
   - Adicionar comandos especiais:
     * `/exit` ou `/quit` - Sair
     * `/clear` - Limpar histÃ³rico
     * `/log` - Mostrar Chain-of-Thought
     * `/metrics` - Mostrar mÃ©tricas da sessÃ£o
   - Implementar timeout visual (30s) para pergunta condicional
   - Adicionar indicadores de status (ğŸ¤” Pensando, âœ… Pronto, âš ï¸ Erro)
   - Suporte para modo debug (`--debug`)

2. **Modos de ExecuÃ§Ã£o:**
   ```bash
   python main.py                    # Modo interativo
   python main.py --client_id C001   # Com client_id prÃ©-definido
   python main.py --debug            # Modo debug
   ```

### Fase 6: API REST (FastAPI)
1. **Setup FastAPI:**
   - Criar estrutura de diretÃ³rios `api/`
   - Implementar Pydantic models (request/response)
   - Configurar CORS e middleware

2. **Implementar Endpoints:**
   - `POST /chat/message` - Enviar mensagem ao agente
   - `POST /chat/session` - Criar nova sessÃ£o
   - `GET /chat/session/{session_id}` - Obter histÃ³rico
   - `DELETE /chat/session/{session_id}` - Encerrar sessÃ£o
   - `GET /health` - Health check
   - `GET /metrics` - MÃ©tricas agregadas

3. **Session Management:**
   - Implementar gerenciador de sessÃµes (in-memory ou Redis)
   - TTL de 30 minutos para sessÃµes inativas
   - Cleanup automÃ¡tico de sessÃµes expiradas

4. **SeguranÃ§a e Performance:**
   - Implementar API Key authentication (header `X-API-Key`)
   - Rate limiting por cliente
   - Tratamento robusto de erros HTTP
   - Async/await em todos os endpoints

5. **DocumentaÃ§Ã£o:**
   - DocumentaÃ§Ã£o automÃ¡tica Swagger em `/docs`
   - Criar collection Postman/Insomnia
   - Exemplos de uso para cada endpoint

6. **ExecuÃ§Ã£o:**
   ```bash
   uvicorn api.main:app --reload          # Desenvolvimento
   uvicorn api.main:app --workers 4       # ProduÃ§Ã£o
   ```

### Fase 7: Testes
1. **Testes UnitÃ¡rios:**
   - Testar Tool 1 com diferentes mÃ©todos de busca
   - Testar Tool 2 com cenÃ¡rios de erro
   - Testar Tool 3 com cache hit/miss/stale

2. **Teste CLI (main.py):**
   - Executar em modo interativo
   - Testar todos os comandos especiais
   - Validar timeout da pergunta condicional
   - Verificar formataÃ§Ã£o visual com rich
   - Testar modo debug

3. **Teste API (FastAPI):**
   - Testar criaÃ§Ã£o e gerenciamento de sessÃµes
   - Validar todos os endpoints
   - Testar health check e mÃ©tricas
   - Validar tratamento de erros
   - Testar rate limiting
   - Verificar documentaÃ§Ã£o Swagger

4. **Teste E2E Completo:**
   - Executar query completa com client_id C001 via CLI
   - Executar mesmo fluxo via API
   - Validar fluxo completo dos 5 passos em ambos
   - Verificar otimizaÃ§Ã£o de custo (pergunta condicional)
   - Analisar logs Chain-of-Thought
   - Comparar mÃ©tricas entre CLI e API

---

## ğŸ“‹ Checklist de ImplementaÃ§Ã£o

- [ ] Setup de dependÃªncias e ambiente
- [ ] Criar estrutura de diretÃ³rios
- [ ] Implementar Tool 1 (SQL Runner)
- [ ] Implementar Tool 2 (Brewery Finder)
- [ ] Implementar Tool 3 (Web Explorer)
- [ ] Implementar RAG Manager (FAISS)
- [ ] Implementar Logger estruturado
- [ ] Implementar Planner Agent
- [ ] Implementar lÃ³gica condicional (timeout)
- [ ] **Implementar main.py (CLI Conversacional)**
- [ ] **Implementar ChatSession manager**
- [ ] **Implementar API FastAPI completa**
- [ ] **Implementar Session Manager para API**
- [ ] **Implementar AutenticaÃ§Ã£o e Rate Limiting**
- [ ] Testes unitÃ¡rios de cada Tool
- [ ] Testes da interface CLI
- [ ] Testes da API (todos endpoints)
- [ ] Teste E2E completo (CLI + API)
- [ ] **Gerar collection Postman/Insomnia**
- [ ] **Criar documentaÃ§Ã£o de uso (CLI + API)**
- [ ] Otimizar performance e custo

---

## ğŸš€ Comandos de ExecuÃ§Ã£o

### CLI Conversacional (main.py)
```bash
# Modo interativo (padrÃ£o)
python main.py

# Com client_id prÃ©-definido
python main.py --client_id C001

# Modo debug (mostra logs detalhados)
python main.py --debug

# Comandos durante execuÃ§Ã£o:
# /exit ou /quit    - Sair do chat
# /clear            - Limpar histÃ³rico
# /log              - Mostrar Chain-of-Thought
# /metrics          - Mostrar mÃ©tricas da sessÃ£o
```

### API REST (FastAPI)
```bash
# Desenvolvimento (com auto-reload)
uvicorn api.main:app --reload --host 0.0.0.0 --port 8000

# ProduÃ§Ã£o (mÃºltiplos workers)
uvicorn api.main:app --host 0.0.0.0 --port 8000 --workers 4

# Acessar documentaÃ§Ã£o Swagger
open http://localhost:8000/docs

# Acessar ReDoc
open http://localhost:8000/redoc
```

### Exemplo de Uso da API
```python
import requests

# Criar sessÃ£o
response = requests.post("http://localhost:8000/chat/session")
session_id = response.json()["session_id"]

# Enviar mensagem
response = requests.post(
    "http://localhost:8000/chat/message",
    json={
        "session_id": session_id,
        "client_id": "C001",
        "message": "Sugira uma nova cervejaria local"
    },
    headers={"X-API-Key": "your-api-key-here"}
)

print(response.json()["response"])
```